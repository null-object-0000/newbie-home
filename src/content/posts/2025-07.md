---
date: 2025-07
author: return null;
tags:
  - 架构设计
  - 解决方案
cover: null
---

# 2025-07 库存管控解决方案

在常规业务场景下，库存管库的强制目标均是**不能超卖**。在此基础上，第二优先：销售速率要快。（高吞吐量，若销售速率过慢，则高并发流量会持续甚至加剧）下文将基于主要的查询、扣减两个常规操作进行不同方案的对比。

- C 端操作：查询、扣减、退还
- B 端操作：查询、初始化、增加、减少

## 计数
``` sql
-- CAS
select stock from goods where id = 123 -- stock: 103
update goods set stock = 102 where id = 123 and stock = 103
-- 不开事务的话，会有 ABA 问题？会有并发问题？开启事务用主键更新会自带行锁互斥（读已提交）

-- CAS + version
select stock, version from goods where id = 123 -- stock: 103, version: 20250718001
update goods set stock = 102, version = 20250718002 
where id = 123 and stock = 103 and version = 20250718001

-- 行级锁
begin;
select * from ticket_stock where id = 5955 for update;
update ticket_stock set quantity = quantity - 1 where id = 5955 and quantity > 0;
commit;

-- Redis decr，可避免超卖，但是在 Redis 故障且数据丢失时会少买
-- 在无法保证 Redis 持久性的前提下，应避免使用 Redis incr 后对比的方式
get key -- 100 > 0 若小于等于 0 则无需 decr
decr key -- 100 -> 99
```

实际需要结合业务场景，若并发量不大，则可直接使用 MySQL + 行级锁的方式
- 若并发量大，但库存量不多，则可基于 Redis + 同步 MySQL（行级锁）的方式
  - 用 Redis 来保证到达 MySQL 的流量只会在库存量范围内
- 若并发量大，且库存量也很多，则可基于 Redis + 异步 MySQL（可批量）的方式
  - 但 Redis 挂时会导致少买，也可在 Redis 挂时降级到 限流 + MySQL（行级锁）
- 若可接受库存缓慢消耗，也可直接限流到MySQL可承受范围，但需要考虑因为策略限制导致无法下单的用户把限流流量占用的问题

## 分桶

将库存一行拆成 N 行，基于请求中参数按照规则将流量分散到多行中（如按照会员号进行 Hash 取模）根据 QPS 要求以及库存量的实际情况进行拆分
- 例如 QPS 要求 1000，库存量有 100000，那么就拆成 100 行
- 请求进来后根据固定规则去第 N 行进行库存扣减

上述方案会受哈希值分布不均影响导致热点问题，此时可参考哈希表冲突时的开放寻址法进行一定数量下的重试，或添加随机值降低冲突率

## 异步
将性能瓶颈部分异步化，但纯异步化只是解决了并发问题，没有解决吞吐量问题。若需要提升销售速率，则需要通过批量操作来提升性能。异步是聚合数据的一种方式。

具体措施可以是将用户请求在做初步检验后扔进队列中，然后提示用户排队中。消费时做批量的库存扣减和写入。处理完成后通知前端，前端通过轮询方式获取排队情况。

## 队列
将库存数值转化成具体的一行行数据，一万个库存就是一万行记录，然后利用 Redis （对于 Redis 的可用性可以通过多中心部署的方式解决）甚至是本地缓存（将库存平分，提前将所有库存编号进行同步（先写 DB 然后写缓存，若缓存全部写成功再同步到 DB）

请求进来后优先通过缓存消费到库存编号，然后根据编号去 MySQL 中通过 CAS 更新使用状态保证并发安全与持久化。