---
date: 2025-12
author: return null;
tags:
  - Java
  - 排查
  - 性能优化
cover: null
---

# 2025-12 高并发时应用宕机问题排查

> 一起因为 OkHttpClient 使用不规范（未单例使用），进而引起的高并发下资源占用过高，从而导致应用服务宕机的问题回顾。

## 一、问题现象

:::timeline
- **2025-12-16 21:39:00** CI/CD 平台告警，应用负载实例存活比率低于 35%
- **2025-12-16 21:42:00** 观察应用监控，发现流量远超日常（QPS≈49,000）
- **2025-12-16 21:45:00** 尝试重启 & 重新部署挂掉的机器（但一直无法重启/操作成功）
:::

![flows_01](/public/posts/2025-12/flows_01.png)


``` dockerfile
# JDK 21 & 机器配置 2C4G x 28（单台需承受 1,750 QPS）
ENTRYPOINT ["java", \
    "-Duser.timezone=GMT+08", \
    "-XX:+UseZGC", \
    "-Xms2867m", \
    "-Xmx2867m", \
    "-XX:+PrintCommandLineFlags", \
    "-XX:+HeapDumpOnOutOfMemoryError", \
    "-XX:HeapDumpPath=java_pid%p.hprof", \
    "-XX:+UseContainerSupport", \
    "-Xlog:gc*:file=gc.log:time,level,tags:filecount=10,filesize=100M", \
    "-jar", \
    "app.jar"]
```

## 二、止损手段

:::timeline
- **2025-12-16 21:52:55** 临时通知运维尝试扩容 +12（此时单台承受 1,225 QPS，按后续压测情况看，此时单台只能承受 200 QPS，扩容数量完全不够）
- **2025-12-16 22:05:30** 流量自然下降，CPU 使用率随之下降，接口耗时回归正常
:::

## 三、排查过程

### 1. OkHttpClient 使用不规范

**2025-12-17** 一开始目光全在某个三方接口上（因为它的响应报文一直很大），一直以为是内存问题，因为有大量 GC 后宕机。之后发现另一个三方接口报文也很大且非核心接口，故开始压测该接口（200 线程 500 QPS）。

    在不变更机器配置（2C4G）的情况下，通过切换 JDK 21 -> 1.8，GC ZGC -> G1 -> CMS 发现效果均不好

**2025-12-25** 通过应用监控大盘发现大量守护线程，排查代码初步怀疑 OkHttpClient 使用不规范导致。

::: details 最小化代码
``` java
package com.example.demo;

import okhttp3.*;

import java.io.IOException;
import java.util.concurrent.*;

public class OkHttpSim {
    static OkHttpClient client = new OkHttpClient();

    public static void main(String[] args) {
        int qps = 500;
        long delayUs = 1_000_000 / qps;
        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();

        scheduler.scheduleAtFixedRate(() -> {
            // 模拟线上错误：每个请求都 new 一个客户端
            Request request = new Request.Builder().url("https://wwww.baidu.com").build();
            // OkHttpClient client = new OkHttpClient();
            client.newCall(request).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                }

                @Override
                public void onResponse(Call call, Response response) {
                    response.close();
                }
            });
        }, 0, delayUs, TimeUnit.MICROSECONDS);
    }
}
```

``` dockerfile
# docker run --name okhttp-test --cpus="2" --memory="4g"
# 第一阶段：编译环境 (保持不变)
FROM maven:3.9.6-eclipse-temurin-21 AS build
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn clean package -DskipTests

# 第二阶段：运行环境
FROM eclipse-temurin:21-jre-jammy
WORKDIR /app
COPY --from=build /app/target/demo-0.0.1-SNAPSHOT.jar app.jar

EXPOSE 9010

# 修正后的 ENTRYPOINT 格式
ENTRYPOINT ["java", \
    "-XX:+UseZGC", \
    "-Xms2867m", \
    "-Xmx2867m", \
    "-XX:+PrintCommandLineFlags", \
    "-XX:+UseContainerSupport", \
    "-Xlog:gc*:file=gc.log:time,level,tags:filecount=10,filesize=100M", \
    "-Dcom.sun.management.jmxremote", \
    "-Dcom.sun.management.jmxremote.port=9010", \
    "-Dcom.sun.management.jmxremote.rmi.port=9010", \
    "-Dcom.sun.management.jmxremote.authenticate=false", \
    "-Dcom.sun.management.jmxremote.ssl=false", \
    "-Djava.rmi.server.hostname=localhost", \
    "-jar", \
    "app.jar"]
```
:::

通过一个最小化代码来进行测试，监测使用单例和每次都实例化的性能差别，从下图可以明显看出差异
![jconsole_01](/public/posts/2025-12/jconsole_01.png)

查阅 OkHttp 的版本更新说明可发现从 [Version 3.0.0-RC1](https://square.github.io/okhttp/changelogs/changelog_3x/#version-300-rc1) 开始，官方建议需要以单例模式使用 OkHttpClient
> **There is no longer a global singleton connection pool. （不再存在全局的单例连接池。）** 
> In OkHttp 2.x, all OkHttpClient instances shared a common connection pool by default. In OkHttp 3.x, each new OkHttpClient gets its own private connection pool.（在 OkHttp 2.x 中，默认情况下所有 OkHttpClient 实例共享一个公共连接池。而在 OkHttp 3.x 中，每个新的 OkHttpClient 都会拥有自己的私有连接池。） 
> Applications should avoid creating many connection pools as doing so prevents connection reuse. Each connection pool holds its own set of connections alive so applications that have many pools also risk exhausting memory!（应用程序应避免创建过多的连接池，因为这样做会妨碍连接复用。每个连接池都会保留自己的连接集处于活跃状态，因此拥有多个连接池的应用程序也有可能耗尽内存！）

> The best practice in OkHttp 3 is to create a single OkHttpClient instance and share it throughout the application. Requests that needs a customized client should call `OkHttpClient.newBuilder()` on that shared instance. This allows customization without the drawbacks of separate connection pools.

### 2. client & server 传输的报文过大

## 四、优化手段

- 以单例的形式使用 OkHttpClient（历史代码直接使用了底层 client，后续已切换至公共包）
- 该项目早前已升级至 JDK 21 故可开启`虚拟线程`优化高并发 IO 密集场景下的资源占用（减少平台线程进而减少内容占用和线程切换时的资源占用）